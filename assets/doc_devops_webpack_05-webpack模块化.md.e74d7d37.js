import{_ as s,o as a,c as n,b as l,d as o,e as p,a as e,r as c}from"./app.399c4537.js";const r=JSON.parse('{"title":"模块化","description":"","frontmatter":{},"headers":[{"level":2,"title":"模块化规范","slug":"模块化规范","link":"#模块化规范","children":[{"level":3,"title":"CommonJS","slug":"commonjs","link":"#commonjs","children":[]},{"level":3,"title":"AMD","slug":"amd","link":"#amd","children":[]},{"level":3,"title":"ES6 Module","slug":"es6-module","link":"#es6-module","children":[]}]},{"level":2,"title":"Webpack工作原理简析","slug":"webpack工作原理简析","link":"#webpack工作原理简析","children":[]},{"level":2,"title":"webpack对Module 的增强","slug":"webpack对module-的增强","link":"#webpack对module-的增强","children":[{"level":3,"title":"import()和神奇注释","slug":"import-和神奇注释","link":"#import-和神奇注释","children":[]},{"level":3,"title":"require.resolve() 和require.resolveWeak()","slug":"require-resolve-和require-resolveweak","link":"#require-resolve-和require-resolveweak","children":[]},{"level":3,"title":"require.context()","slug":"require-context","link":"#require-context","children":[]},{"level":3,"title":"require.include()","slug":"require-include","link":"#require-include","children":[]}]},{"level":2,"title":"资源的模块化处理","slug":"资源的模块化处理","link":"#资源的模块化处理","children":[{"level":3,"title":"@import和import","slug":"import和import","link":"#import和import","children":[]},{"level":3,"title":"把资源作为模块引入","slug":"把资源作为模块引入","link":"#把资源作为模块引入","children":[]}]}],"relativePath":"doc/devops/webpack/05-webpack模块化.md","lastUpdated":1663313048000}'),t={name:"doc/devops/webpack/05-webpack模块化.md"},D=o("h1",{id:"模块化",tabindex:"-1"},[p("模块化 "),o("a",{class:"header-anchor",href:"#模块化","aria-hidden":"true"},"#")],-1),y=e('<h2 id="模块化规范" tabindex="-1">模块化规范 <a class="header-anchor" href="#模块化规范" aria-hidden="true">#</a></h2><p>三大 JavaScript 主流模块规范：CommonJS、AMD 和 ES6 Module。</p><h3 id="commonjs" tabindex="-1">CommonJS <a class="header-anchor" href="#commonjs" aria-hidden="true">#</a></h3><p><a href="https://nodejs.org/docs/latest/api/modules.html" target="_blank" rel="noreferrer">CommonJS </a>规范是 2009 年一名来自 Mozilla 团队的工程师 Kevin Dangoor 开始设计一个叫 ServerJS 的项目提出来的，随着 Node.js 的广泛应用，被广泛接受。通过 <strong>ServerJS</strong> 这个名字就可以知道，CommonJS 主要是服务端用的模块规范。</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#676E95;">// sayhi.js</span></span>\n<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> hi </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello world</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">sayHi</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hi</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> sayHi</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#676E95;">// index.js</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> sayHi </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./sayhi.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">sayHi</span><span style="color:#A6ACCD;">())</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>上面的代码就是 CommonJS 语法，使用了<code>require</code>来导入一个模块，<code>module.exports</code>导出模块。在 Node.js 中<a href="https://nodejs.org/docs/latest/api/modules.html#modules_the_module_wrapper" target="_blank" rel="noreferrer">实际代码 </a>会被处理成下面代码而被应用：</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">exports</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">require</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">module</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">__filename</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">__dirname</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// ...</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// 模块的代码在这里</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// ...</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>CommonJS 的问题：<strong>Commonjs规范是不适合浏览器的，但由于有了打包工具的支撑，通过处理的Commonjs也可以在浏览器中使用。</strong></p><blockquote><p>CommonJS 规范是 JavaScript 中最常见的模块格式规范，这一标准的设计初衷是为了让 JavaScript 在多个环境下都实现模块化。</p><p>起先主要应用在 Node.js 服务端中，但是 Node.js 中的实现依赖了 Node.js 本身功能的实现，包括了 Node.js 的文件系统等，这个规范在浏览器环境是没法使用的。</p><p>后来随着 <a href="http://browserify.org/" target="_blank" rel="noreferrer">Browserify </a>和 Webpack 等打包工具的崛起，通过处理的 CommonJS 前端代码也可以在浏览器中使用。</p></blockquote><h3 id="amd" tabindex="-1">AMD <a class="header-anchor" href="#amd" aria-hidden="true">#</a></h3><p><a href="https://requirejs.org/docs/whyamd.html" target="_blank" rel="noreferrer">AMD 规范 </a>是在 CommonJS 规范之后推出的一个解决 web 页面动态异步加载 JavaScript 的规范，相对于 CommonJS 规范，它最大特点是浏览器内支持、实现简单、并且支持异步加载，AMD 规范最早是随着<a href="https://requirejs.org/docs/api.html" target="_blank" rel="noreferrer">RequireJS </a>发展而提出来的，它最核心的是两个方法：</p><ul><li><code>require()</code>：引入其他模块；</li><li><code>define()</code>：定义新的模块。</li></ul><p>基本语法如下：</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#676E95;">// sayhi.js</span></span>\n<span class="line"><span style="color:#82AAFF;">define</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hi</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello world</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">sayHi</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hi</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;">// index.js</span></span>\n<span class="line"><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">([</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./sayhi.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">sayHi</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#82AAFF;">sayHi</span><span style="color:#F07178;">())</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>AMD 提出来之后，也有很多变种的规范提出来，比如国内 <a href="https://seajs.github.io/seajs/" target="_blank" rel="noreferrer">Sea.js </a>的 <a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="noreferrer">CMD </a>，还有兼容 CommonJS 和 AMD 的 <a href="https://github.com/umdjs/umd" target="_blank" rel="noreferrer">UMD 规范 </a>（Universal Module Definition）。虽然 AMD 的模式很适合浏览器端的开发，但是随着 npm 包管理的机制越来越流行，这种方式可能会逐步的被淘汰掉。</p><p>AMD 规范的问题：<strong>依赖前置加大了开发的难度，无论在阅读代码还是编写代码的时，都会导致引入的模块内容是条件性执行的。</strong></p><blockquote><p>在 AMD 规范中，要声明一个模块，那么需要指定该模块用到的所有依赖项，这些依赖项会被当做形参传到 <code>factory</code>（<code>define</code>方法传入的函数叫做<code>factory</code>）中，对于依赖的模块会提前执行，这种做法叫做 <strong>依赖前置</strong> 。依赖前置加大了开发的难度，无论在阅读代码还是编写代码的时，都会导致引入的模块内容是条件性执行的。</p><p><strong>而且不管 AMD 还是 CommonJS 都没有统一浏览器和客户端的模块化规范。</strong></p></blockquote><h3 id="es6-module" tabindex="-1">ES6 Module <a class="header-anchor" href="#es6-module" aria-hidden="true">#</a></h3><p>ES6 Module，又称为 ES2015 modules，是 ES2015 标准提出来的一种模块加载方式，也是 ECMAScript 官方提出的方案，作为 ES 标准，不仅仅在 Web 现代浏览器（例如 Chrome）上面得到实现，而且在 Node.js 9+ 版本也得到原生支持（需要加上<code>--experimental-modules</code>使用）。</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#676E95;">// sayhi.js</span></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> hi </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello world</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">sayHi</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hi</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;">// index.js</span></span>\n<span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;"> sayHi </span><span style="color:#89DDFF;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./sayhi</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">sayHi</span><span style="color:#A6ACCD;">())</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>对于前端项目，可以通过 Babel 或者 Typescript 进行提前体验。</p><blockquote><p>随着主流浏览器逐步开始支持 ES Modules（ESM） 标准，越来越多的目光投注于 Node.js 对于 ESM 的支持实现上。</p></blockquote><p>目前 Node.js 使用 CommonJS 作为官方的模块解决方案，虽然内置的模块方案促进了 Node.js 的流行，但是也为引入新的 ES Modules 造成了一定的阻碍。不过 Node.js 9.0+ 已经支持 ESM 语法，看示例：</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#676E95;">// sayhi.mjs</span></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> hi </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello world</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">sayHi</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hi</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;">// index.mjs</span></span>\n<span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;"> sayHi </span><span style="color:#89DDFF;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./sayhi.mjs</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">sayHi</span><span style="color:#A6ACCD;">())</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;">// 使用命令</span></span>\n<span class="line"><span style="color:#A6ACCD;">➜ node </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">experimental</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">modules index</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">mjs</span></span>\n<span class="line"><span style="color:#A6ACCD;">hello world</span></span>\n<span class="line"></span></code></pre></div><p>需要添加 flag <code>--experimental-modules</code> 来启动 ESM 语法支持，文件则必须使用 <code>.mjs</code> 后缀： <code>node --experimental-modules some-esm-file.mjs</code> 。</p><p><img src="https://b3logfile.com/file/2021/10/eabc8e4ede4b43ee8e577e9cab5649c4.png" alt="image-20210803114427025"></p><h2 id="webpack工作原理简析" tabindex="-1">Webpack工作原理简析 <a class="header-anchor" href="#webpack工作原理简析" aria-hidden="true">#</a></h2><p>在 Web 前端，不仅仅只有 JavaScript，还有 CSS、HTML、图片、字体、富媒体等众多资源，还有一些资源是以类似「方言」的方式存在着，比如 less、sass、各种 js 模板库等，这些资源并不能被直接用在 JavaScript 中，如果在 JavaScript 中像使用模块一样使用，那么可以极大的提高的开发体验：</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> img </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./img/webpack.png</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> style </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./css/style.css</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> template </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./template.ejs</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>这时候，就需要 Webpack 了！<strong>在 Webpack 中，一切皆模块！</strong></p><p>webpack的编译逻辑：</p><ul><li>Webpack 会要对整个代码进行<strong>静态分析</strong> ，分析出各个模块的类型和它们依赖关系</li><li>将不同类型的模块提交给对应的加载器（loader）来处理。</li></ul><p>比如：一个用 Less 写的样式，可以先用 less-loader 将它转成一个 CSS 模块，然后再通过 css-loader 把他插入到页面的 <code>&lt;style&gt;</code> 标签中执行，甚至还可以通过插件将这部分 CSS 导出为 CSS 文件，使用<code>link</code>标签引入到页面中。</p><h2 id="webpack对module-的增强" tabindex="-1">webpack对Module 的增强 <a class="header-anchor" href="#webpack对module-的增强" aria-hidden="true">#</a></h2><p>在 Webpack 中，不仅可以为所欲为的使用 CommonJS 、AMD 和 ES6 Module 三大规范（比如一个文件中混合使用三种规范），还可以使用 Webpack 对 Module 的增强方法和属性。</p><h3 id="import-和神奇注释" tabindex="-1"><code>import()</code>和神奇注释 <a class="header-anchor" href="#import-和神奇注释" aria-hidden="true">#</a></h3><p>在 Webpack 中，<code>import</code>不仅仅是 ES6 Module 的模块导入方式，还是一个类似<code>require</code>的函数（其实这是 <a href="https://whatwg.github.io/loader/" target="_blank" rel="noreferrer">ES2015 loader 规范 </a>的实现），可以通过<code>import(&#39;path/to/module&#39;)</code>的方式引入一个模块，<code>import()</code>返回的是一个<code>Promise</code>对象：</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">path/to/module</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#A6ACCD;">mod</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">mod</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><blockquote><p>参考<a href="/docs-page/doc/devops/webpack/04-ES6语法支持.html##webpack-中使用-babel">先前的一章</a>，来创建基础的ES6的webpack项目。</p></blockquote><p>下面看看使用<code>import()</code>和 import 的打包有什么区别：</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#676E95;">// hello.js</span></span>\n<span class="line"><span style="color:#89DDFF;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;">// lazy.js</span></span>\n<span class="line"><span style="color:#89DDFF;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">lazy module</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;">// index.js</span></span>\n<span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;"> hello </span><span style="color:#89DDFF;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./hello</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./lazy</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#A6ACCD;">lazy</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">lazy</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>执行下命令：</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#A6ACCD;">npx webpack </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">mode development：</span></span>\n<span class="line"></span></code></pre></div><p><img src="https://b3logfile.com/file/2021/10/2752782e74dd49fdb1d72644bf66d58e.png" alt="image-20210804150238493"></p><p>通过打包后的 log 和<code>dist</code>文件夹内容发现，的代码被分割成了两个文件，一个是<code>main.js</code>一个是<code>lazy_js.js</code>，这是因为相对于<code>import from</code>的静态分析打包语法，<code>import()</code>是动态打包语法，即的内容不是第一时间打进<code>main.js</code>的，而是通过异步的方式加载进来的。<strong>代码分割是 webpack 进行代码结构组织，实现动态优化的一个重要功能</strong></p><blockquote><p>与<code>import()</code>用法一样的是<code>require.ensure</code>的方法，这个方法已经被<code>import()</code>方式替换掉；</p><p>针对<code>import()</code>打包产物跟普通的静态分析打包的实现不同之处，后面原理篇讲解打包产出物的时候会详细介绍。</p></blockquote><p>下面再来看下<code>import()</code>的<strong>神奇注释</strong> 特性，上面<code>index.js</code>的代码修改成下面这样，增加注释<code>webpackChunkName: &#39;lazy-name&#39;</code></p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;"> hello </span><span style="color:#89DDFF;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./hello</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#82AAFF;">import</span><span style="color:#A6ACCD;">(</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;">/*</span></span>\n<span class="line"><span style="color:#676E95;">     webpackChunkName: &#39;toimc-lazy&#39;</span></span>\n<span class="line"><span style="color:#676E95;">     */</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./lazy</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#A6ACCD;">lazy</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">lazy</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>则打包后的结果，<code>lasy_js.js</code>变成了<code>toimc-lazy.js</code>了，这个文件的名字就是在<code>import()</code>注释里面指定的<code>webpackChunkName</code>，这就是神奇注释（Magic Comments）。</p><p><img src="https://b3logfile.com/file/2021/10/085b8d6d7ca948a88c343e47af6f4cc3.png" alt="image-20210804150440531"></p><p>目前支持的注释有：</p><ul><li><code>webpackInclude</code>：如果是 import 的一个目录，则可以指定需要引入的文件特性，例如只加载 json 文件：<code>/\\.json$/</code>；</li><li><code>webpackExclude</code>：如果是 import 的一个目录，则可以指定需要过滤的文件，例如 <code>/\\.noimport\\.json$/</code>；</li><li><code>webpackChunkName</code>：这是 chunk 文件的名称，例如 toimc-lazy；</li><li><code>webpackPrefetch</code>: 是否预取模块，及其优先级，可选值<code>true</code>、或者整数优先级别，0 相当于 true，webpack 4.6+支持；</li><li><code>webpackPreload</code>: 是否预加载模块，及其优先级，可选值<code>true</code>、或者整数优先级别，0 相当于 true，webpack 4.6+支持；</li><li><code>webpackMode</code>: 可选值<code>lazy</code>/<code>lazy-once</code>/<code>eager</code>/<code>weak</code>。</li></ul><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;"> hello </span><span style="color:#89DDFF;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./hello</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(hello)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#82AAFF;">import</span><span style="color:#A6ACCD;">(</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;">/* webpackChunkName: &#39;toimc-lazy&#39; */</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;">/* webpackInclude: /\\.json$/ */</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;">/* webpackExclude: /\\.noimport\\.json$/ */</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;">/* webpackMode: &quot;lazy&quot; */</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;">/* webpackPrefetch: true */</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;">/* webpackPreload: true */</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./lazy</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#A6ACCD;">lazy</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">lazy</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>这里最复杂的是<code>webpackMode</code>：</p><ul><li><code>lazy</code>：是默认的模式，为每个 <code>import()</code> 导入的模块，生成一个可延迟加载 chunk；</li><li><code>lazy-once</code>：生成一个可以满足所有 <code>import()</code> 调用的<strong>单个</strong> 可延迟加载 chunk，此 chunk 将在第一次 import() 调用时获取，随后的 import() 调用将使用相同的网络响应；注意，这种模式仅在部分动态语句中有意义，例如 import(<code>./locales/${language}.json</code>)，其中可能含有多个被请求的模块路径；</li><li><code>eager</code>：不会生成额外的 chunk，所有模块都被当前 chunk 引入，并且没有额外的网络请求。仍然会返回 Promise，但是是 resolved 状态。和静态导入相对比，在调用 <code>import()</code> 完成之前，该模块不会被执行。</li><li><code>weak</code>：尝试加载模块，如果该模块函数已经以其他方式加载（即，另一个 chunk 导入过此模块，或包含模块的脚本被加载）。仍然会返回 Promise，但是只有在客户端上已经有该 chunk 时才成功解析。如果该模块不可用，Promise 将会是 rejected 状态，并且网络请求永远不会执行。当需要的 chunks 始终在（嵌入在页面中的）初始请求中手动提供，而不是在应用程序导航在最初没有提供的模块导入的情况触发，这对于 Server 端渲染（SSR，Server-Side Render）是非常有用的。</li></ul><p>通过上面的神奇注释，<code>import()</code>不再是简单的 JavaScript 异步加载器，还是任意模块资源的加载器，举例说明：如果页面用到的图片都放在<code>src/assets/img</code>文件夹下，你们可以通过下面方式将用到的图片打包到一起：</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#82AAFF;">import</span><span style="color:#A6ACCD;">(</span><span style="color:#676E95;">/* webpackChunkName: &quot;image&quot;, webpackInclude: /\\.(png|jpg|gif)/ */</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./assets/img</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><blockquote><p>prefetch 优先级低于 preload，preload 会并行或者加载完主文件之后立即加载；prefetch 则会在主文件之后、空闲时在加载。prefetch 和 preload 可以用于提前加载图片、样式等资源的功能。</p></blockquote><h3 id="require-resolve-和require-resolveweak" tabindex="-1"><code>require.resolve()</code> 和<code>require.resolveWeak()</code> <a class="header-anchor" href="#require-resolve-和require-resolveweak" aria-hidden="true">#</a></h3><p><code>require.resolve()</code> 和 <code>require.resolveWeak()</code>都可以获取模块的唯一 ID（moduleId），区别在于<code>require.resolve()</code>会把模块真实引入进 bundle，而<code>require.resolveWeak()</code>则不会，配合<code>require.cache</code>和 <code>__webpack_modules__</code>可以用于判断模块是否加载成功或者是否可用。</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#89DDFF;">if</span><span style="color:#A6ACCD;"> (__webpack_modules__[require</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolveWeak</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)]) </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 当模块可用时，做一些事情...</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">if</span><span style="color:#A6ACCD;"> (require</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">cache[require</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolveWeak</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)]) </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 当模块被加载之前，做一些事情...</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;">// 可以执行动态解析（&quot;context&quot;）</span></span>\n<span class="line"><span style="color:#676E95;">// 与其他 require/import 方法类似。</span></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> page </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Foo</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">__webpack_modules__[require</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolveWeak</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">`</span><span style="color:#C3E88D;">./page/</span><span style="color:#89DDFF;">${</span><span style="color:#A6ACCD;">page</span><span style="color:#89DDFF;">}`</span><span style="color:#A6ACCD;">)]</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><h3 id="require-context" tabindex="-1"><code>require.context()</code> <a class="header-anchor" href="#require-context" aria-hidden="true">#</a></h3><p><strong><code>require.context(directory, includeSubdirs, filter)</code>可以批量将<code>directory</code>内的文件全部引入进文件(这个在视频中有介绍到)</strong> ，并且返回一个具有<code>resolve</code>的 context 对象，使用<code>context.resolve(moduleId)</code>则返回对应的模块。</p><ul><li>directory：目录 string；</li><li>includeSubdirs：是否包含子目录，可选，默认值是 true；</li><li>filter：过滤正则规则，可选项。</li></ul><blockquote><p>Tips：注意 <code>require.context()</code> 会将所有的文件都引入进 bundle！</p></blockquote><h3 id="require-include" tabindex="-1"><code>require.include()</code> <a class="header-anchor" href="#require-include" aria-hidden="true">#</a></h3><blockquote><p><code>require.include()</code>已被废弃，不久将被删除。</p></blockquote><p><code>require.include(dependency)</code>顾名思义为引入某个依赖，但是并不执行它，可以用于优化 chunk，例如下面示例代码：</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#A6ACCD;">require</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">include</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./hello.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">require</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">ensure</span><span style="color:#A6ACCD;">([</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./hello.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./weak.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">require</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#676E95;">/* ... */</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">require</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">ensure</span><span style="color:#A6ACCD;">([</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./hello.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./lazy.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">require</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#676E95;">/* ... */</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><h2 id="资源的模块化处理" tabindex="-1">资源的模块化处理 <a class="header-anchor" href="#资源的模块化处理" aria-hidden="true">#</a></h2><p>Webpack 还对一些常用的 Node.js 模块和属性进行了 mock，例如：在 web 的 js 文件中可以直接引入 Node.js 的<code>querystring</code>模块，这个模块实际引入的是<a href="https://github.com/webpack/node-libs-browser" target="_blank" rel="noreferrer">node-libs-browser </a>来对 Node.js 核心库 polyfill，详细在 web 页面中可以用的 Node.js 模块，可以参考<a href="https://github.com/webpack/node-libs-browser" target="_blank" rel="noreferrer">node-libs-browser </a>Readme 文件的表格。</p><h3 id="import和import" tabindex="-1"><code>@import</code>和<code>import</code> <a class="header-anchor" href="#import和import" aria-hidden="true">#</a></h3><p>在 Webpack 中的 css （包括其预处理语言，例如 Less、Sass）等，都可以在内部通过<code>@import</code>语法直接引入使用：</p><div class="language-css"><button class="copy"></button><span class="lang">css</span><pre><code><span class="line"><span style="color:#89DDFF;">@import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vars.less</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#FFCB6B;">body</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">background</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> @bg-color</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><p>除了样式文件中的<code>@import</code>，在 JavaScript 文件中，还支持直接使用 ES6 Module 的<code>import</code>（包括 <code>require</code>）直接引入样式文件，例如：</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;"> styles </span><span style="color:#89DDFF;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./style.css</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>JavaScript 的这种语法其实是 <a href="https://github.com/css-modules/css-modules" target="_blank" rel="noreferrer">CSS Modules 语法 </a>，目前浏览器支持程度有限，但是在 Webpack 中，可以通过配置 loader 优先使用这种方式！</p><blockquote><p>后面讲解 CSS 样式配置的时候会更加详细的讲解 CSS Modules</p></blockquote><h3 id="把资源作为模块引入" tabindex="-1">把资源作为模块引入 <a class="header-anchor" href="#把资源作为模块引入" aria-hidden="true">#</a></h3><p>在 Webpack 中，除了 CSS 可以直接使用<code>import</code>语法引入，类似 HTML 和页面模板等，可以直接使用对应的 loader ，通过下面的语法来引入：</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> html </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">html-loader!./loader.html</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(html)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>上面的代码得到<code>html</code>变量实际为引入的<code>loader.html</code>的 string 片段。除了 html，类似模板文件，还可以直接转换为对应的 render 函数，例如下面代码使用了<a href="https://www.npmjs.com/package/ejs-loader" target="_blank" rel="noreferrer">ejs-loader </a>：</p><div class="language-js"><button class="copy"></button><span class="lang">js</span><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> render </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ejs!./file.ejs</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#676E95;">// =&gt; 得到 ejs 编译后的 render 函数</span></span>\n<span class="line"><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">(data)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 传入 data，直接返回的是 html 片段</span></span>\n<span class="line"></span></code></pre></div><blockquote><p>原理篇将动手手写一个 <code>markdown-loader</code> ，更深入的了解其功能和原理实现。</p></blockquote><p>后续的一章，将会介绍webpack中重要的loaders处理，webpack借助loaders来处理各式各样的资源。</p>',85);const F=s(t,[["render",function(s,o,p,e,r,t){const F=c("VueJobs");return a(),n("div",null,[D,l(F),y])}]]);export{r as __pageData,F as default};
