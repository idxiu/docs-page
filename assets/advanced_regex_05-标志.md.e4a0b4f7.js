import{_ as e,o as t,c as r,b as a,d as n,e as o,a as d,r as s}from"./app.4b8e00fa.js";const l=JSON.parse('{"title":"5. 标志","description":"","frontmatter":{},"headers":[{"level":3,"title":"5.1 忽略大小写 (Case Insensitive)","slug":"_5-1-忽略大小写-case-insensitive","link":"#_5-1-忽略大小写-case-insensitive","children":[]},{"level":3,"title":"5.2 全局搜索 (Global search)","slug":"_5-2-全局搜索-global-search","link":"#_5-2-全局搜索-global-search","children":[]},{"level":3,"title":"5.3 多行修饰符 (Multiline)","slug":"_5-3-多行修饰符-multiline","link":"#_5-3-多行修饰符-multiline","children":[]}],"relativePath":"advanced/regex/05-标志.md","lastUpdated":1683631174000}'),h={name:"advanced/regex/05-标志.md"},c=n("h1",{id:"_5-标志",tabindex:"-1"},[o("5. 标志 "),n("a",{class:"header-anchor",href:"#_5-标志","aria-hidden":"true"},"#")],-1),g=d('<p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p><table><thead><tr><th style="text-align:center;">标志</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center;">i</td><td>忽略大小写。</td></tr><tr><td style="text-align:center;">g</td><td>全局搜索。</td></tr><tr><td style="text-align:center;">m</td><td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td></tr></tbody></table><h3 id="_5-1-忽略大小写-case-insensitive" tabindex="-1">5.1 忽略大小写 (Case Insensitive) <a class="header-anchor" href="#_5-1-忽略大小写-case-insensitive" aria-hidden="true">#</a></h3><p>修饰语 <code>i</code> 用于忽略大小写。 例如，表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code>，<code>g</code> 表示全局搜索。</p><pre>&quot;The&quot; =&gt; <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.\n</pre><p><a href="https://regex101.com/r/dpQyf9/1" target="_blank" rel="noreferrer">在线练习</a></p><pre>&quot;/The/gi&quot; =&gt; <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.\n</pre><p><a href="https://regex101.com/r/ahfiuh/1" target="_blank" rel="noreferrer">在线练习</a></p><h3 id="_5-2-全局搜索-global-search" tabindex="-1">5.2 全局搜索 (Global search) <a class="header-anchor" href="#_5-2-全局搜索-global-search" aria-hidden="true">#</a></h3><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。 例如，表达式 <code>/.(at)/g</code> 表示搜索 任意字符（除了换行）+ <code>at</code>，并返回全部结果。</p><pre>&quot;/.(at)/&quot; =&gt; The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.\n</pre><p><a href="https://regex101.com/r/jnk6gM/1" target="_blank" rel="noreferrer">在线练习</a></p><pre>&quot;/.(at)/g&quot; =&gt; The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.\n</pre><p><a href="https://regex101.com/r/dO1nef/1" target="_blank" rel="noreferrer">在线练习</a></p><h3 id="_5-3-多行修饰符-multiline" tabindex="-1">5.3 多行修饰符 (Multiline) <a class="header-anchor" href="#_5-3-多行修饰符-multiline" aria-hidden="true">#</a></h3><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p><p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code>。</p><p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾。</p><pre>&quot;/.at(.)?$/&quot; =&gt; The fat\n                cat sat\n                on the <a href="#learn-regex"><strong>mat.</strong></a>\n</pre><p><a href="https://regex101.com/r/hoGMkP/1" target="_blank" rel="noreferrer">在线练习</a></p><pre>&quot;/.at(.)?$/gm&quot; =&gt; The <a href="#learn-regex"><strong>fat</strong></a>\n                  cat <a href="#learn-regex"><strong>sat</strong></a>\n                  on the <a href="#learn-regex"><strong>mat.</strong></a>\n</pre><p><a href="https://regex101.com/r/E88WE2/1" target="_blank" rel="noreferrer">在线练习</a></p>',22);const i=e(h,[["render",function(e,n,o,d,l,h){const i=s("VueJobs");return t(),r("div",null,[c,a(i),g])}]]);export{l as __pageData,i as default};
